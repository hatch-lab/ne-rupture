function Tracks=LucianTrackfromStartGap(AllStatsClean)

% this function is used to generate tracks starting at T0 from the
% segmentation data generated by LucianSegment.m
%
% Input argument:
%
% AllStats   m-by-1 cell array of structures, one array per time point
%
% Output argument:
%
% Tracks   n-by-1 cell array of structures, one array per tracked cell
% each structures contain p rows, one row per consecutive time point
% starting at T0

%% Data allocation
ncellsT0=numel(AllStatsClean{1}); %define number of cells at T0
nframes=size(AllStatsClean,1); %define total number of frames
Tracks=cell(ncellsT0,1); %preallocate Tracks cell array

%% Cell tracking

%loop thru each cell from T0
for i=1:ncellsT0
    Tracks{i}=AllStatsClean{1}(i);
    % Dist=0;
    %loop thru each time point to generate track
    for j=1:nframes-1
        C=Tracks{i}(j);
        cc=C.Centroid;
        
        
        if j<nframes-11 % This if statement concatenates Stats of 10 consecutive frames (or all remnant frames) to search for closest neighbors...
            Cn=vertcat(AllStatsClean{j+1:j+11}); %... and overcome gaps in segmentation between frames
        else
            Cn=vertcat(AllStatsClean{j+1:nframes});
        end
        nCellnext=numel(Cn);
        ccn=reshape([Cn.Centroid],2,nCellnext)';
        Dc=ccn-cc;
        H=hypot(Dc(:,1),Dc(:,2)); %measure distance between centroid of cell ith at t=j and centroids of all cells at t=j+1 to j+10
        %[mH, mid]=min(H); %search for minimal distance
        tf=H<50;
        
        % the following block to find the closest timeframe of the closest
        % neighbor
        if any(tf) 
            Cn(~tf)=[];
            H(~tf)=[];
            tFrame=[Cn.TimeFrame]';
            DeltaFrame=tFrame-j;
            [~, mid]=min(DeltaFrame);
            [mH, Hid]=min(H);
            %if mH<50 && numel(mH)==1 %if minimum value shared by only one cell and less than 50 pixels
            %Dist(j+1)=mH;
            Tracks{i}=[Tracks{i}; Cn(Hid)]; %add cell to track ith
        else
            %             Dist=num2cell(Dist);
            %             [Tracks{i}.Dist]=Dist{:}; %add measured distance and stop tracking
            break
        end
    end
    %     Dist=num2cell(Dist);
    %     [Tracks{i}.Dist]=Dist{:}; %add measure distance when reaching last frame
end

% remove duplicated timepoints
for k=1:numel(Tracks)
    F=[Tracks{k}.TimeFrame];
    [FU,Ti,Fi]=unique(F);
    Tracks{k}=Tracks{k}(Ti);
end

for i=1:numel(Tracks)
    Tracks{i}=rmfield(Tracks{i},{'PixelIdxList','PixelValues','CytoValues'});
end


% fill in missing datapoints by linear interpolation and Z-normalize the
% cytoplasmic intensity (ZCI)
for i=1:numel(Tracks)
    CI=[Tracks{i}.CytoIntensity]';
    CI=fillmissing(CI,'linear');
    mCI=mean(CI);sCI=std(CI);
    ZCI=(CI-mCI)./sCI;
    ZCI=num2cell(ZCI);
    [Tracks{i}.ZCI]=deal(ZCI{:});
end

